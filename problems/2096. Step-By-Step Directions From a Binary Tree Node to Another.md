# 2096. Step-By-Step Directions From a Binary Tree Node to Another #

## Problem
https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/

## Problem Description

You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.  

Find the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:  

 * 'L' means to go from a node to its left child node.
 * 'R' means to go from a node to its right child node.
 * 'U' means to go from a node to its parent node.
   
Return the step-by-step directions of the shortest path from node s to node t.

### Example 1:

![image](https://github.com/user-attachments/assets/bcf5c9d7-8176-4218-851e-4b37c416a12d)

Input: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6  

Output: "UURL"  

Explanation: The shortest path is: 3 → 1 → 5 → 2 → 6.  

### Example 2:  

![image](https://github.com/user-attachments/assets/9245b088-d3d7-4e0f-a996-88f2b07c4ce0)

Input: root = [2,1], startValue = 2, destValue = 1  

Output: "L"  

Explanation: The shortest path is: 2 → 1.  


### Constraints:  

* The number of nodes in the tree is n.
* 2 <= n <= 105
* 1 <= Node.val <= n
* All the values in the tree are unique.
* 1 <= startValue, destValue <= n
* startValue != destValue

## Code
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    TreeNode* LCA(TreeNode* root, int startValue, int destValue){

        if (root == NULL || root->val == startValue || root->val == destValue)
            return root;

        TreeNode* leftValue = LCA(root->left, startValue, destValue);
        TreeNode* rightValue = LCA(root->right, startValue, destValue);

        if (leftValue == NULL) 
            return rightValue;
        else if (rightValue == NULL)
            return leftValue;
        else
            return root;

    }

    bool findUpPath(TreeNode* root, int findValue, string &path){
        
        if (root == NULL) return false;
        else if (root->val == findValue) return true;

        if (findUpPath(root->left, findValue, path) || findUpPath(root->right, findValue, path)){
            path += 'U';    
            return true;
        }

        return false;
    }

    bool findLRPath(TreeNode* root, int findValue, string &path){

        if (root == NULL) return false;
        else if (root->val == findValue) return true;

        if (findLRPath(root->left, findValue, path)){
            path += 'L';    
            return true;
        }else if (findLRPath(root->right, findValue, path)){
            path += 'R';
            return true;
        }
        return false;
    }

public:
    string getDirections(TreeNode* root, int startValue, int destValue) {

        string firstPath = "";
        string secondPath = "";
        string path = "";

        TreeNode* ancestor = LCA(root, startValue, destValue);
        findUpPath(ancestor, startValue, firstPath);
        findLRPath(ancestor, destValue, secondPath);

        reverse(secondPath.begin(), secondPath.end());
        path = firstPath + secondPath;

        return path;

    }
};

```
